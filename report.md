فایل اول:
# `parser`
## الگوی facade:

 کلاس `Parser` در سازنده خود کار زیادی انجام می‌دهد. می‌توان یک کلاس `ParserInitializer` ایجاد کرد که وظیفه راه‌اندازی کلاس `Parser` را بر عهده بگیرد. به این ترتیب، کلاس `Parser` فقط نیاز دارد با کلاس `ParserInitializer` ارتباط برقرار کند، که به عنوان یک نمایش برای فرآیند راه‌اندازی عمل می‌کند.

 ## الگوی State/Strategy Pattern:

 متد `startParse` شامل یک عبارت `switch` است که رفتار متد را بر اساس `currentAction.action` تغییر می‌دهد. این یک نامزد عالی برای الگوی وضعیت یا استراتژی است. می‌توان یک رابط `ActionStrategy` با یک متد `executeAction()` ایجاد کرد. سپس، برای هر مورد در عبارت `switch،` یک کلاس ایجاد می‌کنیم که `ActionStrategy` را پیاده‌سازی می‌کند.

 
 ## الگوی Separate Query From Modifier: 

  متد `startParse` هم وضعیت شیء `Parser `را تغییر می‌دهد و هم یک نتیجه را برمی‌گرداند. ما می‌توان این دو وظیفه را در متدهای مختلف جدا کرد.


## دیگر الگوها:
الگوی Extract Method: 

متد `startParse` بسیار طولانی است. می‌توان بخش‌هایی از آن را در متدهای جداگانه استخراج کرد تا خوانایی و قابلیت نگهداری را بهبود بخشد.



فایل دوم:
# `CodeGenerator`
 ## الگوی State/Strategy Pattern:

 می‌توان از یک نقشه برای جایگزینی عبارت `switch` استفاده کرد، که یک شکل از الگوی استراتژی است.


 ## الگوی Separate Query From Modifier: 



متد pid هم وضعیت `symbolStack` را تغییر می‌دهد و هم `symbolTable` را پرس و جو می‌کند. می‌توان این دو را در دو متد جداگانه جدا کرد.

## دیگر الگوها:

الگوی Replace Nested Conditional with Guard Clauses: 

عبارت `if` می‌تواند با یک شرط محافظ جایگزین شود تا کد قابل خواندن‌تر شود.

الگوی Replace Exception with Test: 

به جای گرفتن یک استثنا، می‌توان بررسی کرد که آیا نماد در `symbolTable` قبل از دسترسی به آن وجود دارد.


# سوالات:
## سوال 1:
کد تمیز: کدهایی که درک و فهم آن‌ها آسان است، به راحتی می‌توان آن‌ها را ویرایش کرد و نگهداری از آن‌ها را هم می‌توان به سادگی انجام داد.

بدهی فنی: اقدام‌هایی که تیم مهندسی برای تسریع در تحویل بخشی از پروژه انجام می‌دهد و اغلب باید در بازه‌ی زمانی دیگری اصلاح ‌شود.

بوی بد: ویژگی‌ها یا نشانه‌هایی در کد یک برنامه که حاکی از وجود مشکلاتی در عمق برنامه باشند.

## سوال 2:
- Bloaters این نوع بوها مربوط به کدهایی هستند که به شدت از نظر سایزی بزرگ و حجیم شده‌اند و کار کردن با آن‌ها بسیار سخت می‌شود.
- Object-Orientation Abusersاین نوع بوها زمانی ایجاد می‌شوند که قواعد و روش‌های برنامه‌نویسی شیءگرا به درستی رعایت نشده باشند.
- Change Preventersاین نوع بوها زمانی ایجاد می‌شوند که تغییرات کوچک در کد، باعث ایجاد تغییرات گسترده در سایر بخش‌های کد می‌شوند.
- Dispensablesاین نوع بوها زمانی ایجاد می‌شوند که بخش‌هایی از کد وجود دارند که می‌توان آن‌ها را حذف کرد و کد همچنان به درستی کار می‌کند.
- Couplersاین نوع بوها زمانی ایجاد می‌شوند که یک بخش از کد به شدت به بخش دیگری وابسته شده است.

## سوال 3:
 در دسته‌بندی Dispensablesقرار می‌گیرد.
 
برای برطرف کردن این بوی بد، می‌توان از بازآرایی Inline Classاستفاده کرد.

در مواقعی که کلاسی با وظایف و مسئولیت‌های خاص و محدود، اما برای فهم بهتر ساختار کد یا جلوگیری از پیچیدگی بیش از حد کد، استفاده شده باشد، می‌توان این بوی بد را نادیده گرفت.

